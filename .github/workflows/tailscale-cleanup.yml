# ‚ö†Ô∏è SECURITY NOTICE:
# This workflow defaults to GitHub-hosted runners for safety in public repositories.
# Only use runner_type: "self-hosted" in PRIVATE repositories with trusted contributors.
# Fork PRs will require manual approval before running infrastructure operations.

name: Cleanup Orphaned Tailscale Devices

# This workflow is a backup cleanup mechanism
# With ephemeral keys, devices should auto-remove, but this provides additional cleanup
# for any edge cases or non-ephemeral devices

on:
  schedule:
    # Run weekly on Sunday at 3 AM
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      days_offline:
        description: 'Remove devices offline for more than X days'
        required: false
        default: '7'
        type: string
      dry_run:
        description: 'Dry run - only show what would be deleted'
        required: false
        default: true
        type: boolean
      runner_type:
        description: 'Runner type: "github-hosted" or "self-hosted". ‚ö†Ô∏è Use self-hosted ONLY in private repositories.'
        required: false
        default: 'github-hosted'
        type: string
      tailscale_tags:
        description: 'Tailscale ACL tags for GitHub-hosted runner'
        required: false
        default: 'tag:ci'
        type: string

# Limit permissions for security
permissions:
  contents: read

jobs:
  check-runner-access:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      runner: ${{ steps.select-runner.outputs.runner }}
    steps:
      - name: Select runner based on org membership
        id: select-runner
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const requestedRunner = '${{ inputs.runner_type || 'github-hosted' }}';
            
            // Default to github-hosted
            let runner = 'ubuntu-latest';
            
            // Block fork PRs from self-hosted
            if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
              const prRepo = context.payload.pull_request?.head?.repo?.full_name;
              if (prRepo !== `${context.repo.owner}/${context.repo.repo}`) {
                core.warning('Fork PRs use GitHub-hosted runners only');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
            }
            
            // If self-hosted requested, verify org membership
            if (requestedRunner === 'self-hosted') {
              if (context.repo.owner !== 'KoraMaple') {
                core.warning('Self-hosted only available for KoraMaple org repos');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
              
              try {
                const { data } = await github.rest.orgs.getMembershipForUser({
                  org: 'KoraMaple',
                  username: context.actor
                });
                if (data.state === 'active') {
                  core.info(`‚úì ${context.actor} is KoraMaple org member - self-hosted allowed`);
                  runner = 'self-hosted';
                }
              } catch (e) {
                core.warning(`${context.actor} is not a KoraMaple org member - using GitHub-hosted`);
              }
            }
            
            core.setOutput('runner', runner);

  cleanup:
    needs: check-runner-access
    runs-on: ${{ needs.check-runner-access.outputs.runner }}
    # Prevent fork PRs from running infrastructure operations - maintainers must explicitly trigger
    if: |
      github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name == github.repository
    
    steps:
      # Connect to Tailscale for GitHub-hosted runners
      - name: Connect to Tailscale
        if: needs.check-runner-access.outputs.runner == 'ubuntu-latest'
        uses: tailscale/github-action@53acf823325fe9ca47f4cdaa951f90b4b0de5bb9 # v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          tags: ${{ inputs.tailscale_tags }}

      - name: Checkout Repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Install Doppler CLI
        uses: dopplerhq/cli-action@v3 # v3
      
      - name: Configure Doppler
        run: |
          doppler setup --project "${{ secrets.DOPPLER_TARGET_PROJECT }}" --config "${{ secrets.DOPPLER_TARGET_CONFIG }}" --no-interactive
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Find and Remove Orphaned Tailscale Devices
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Mask all sensitive values to prevent log exposure
          [ -n "$TAILSCALE_OAUTH_CLIENT_SECRET" ] && echo "::add-mask::$TAILSCALE_OAUTH_CLIENT_SECRET"
          [ -n "$TS_AUTHKEY" ] && echo "::add-mask::$TS_AUTHKEY"
          [ -n "$TAILSCALE_AUTH_KEY" ] && echo "::add-mask::$TAILSCALE_AUTH_KEY"
          
          DAYS_OFFLINE="${{ inputs.days_offline || '7' }}"
          DRY_RUN="${{ inputs.dry_run || 'true' }}"
          
          echo "üîç Searching for Tailscale devices offline for more than $DAYS_OFFLINE days..."
          echo "Dry run: $DRY_RUN"
          
          # Install Tailscale CLI if not present
          if ! command -v tailscale &> /dev/null; then
            echo "Installing Tailscale CLI..."
            curl -fsSL https://tailscale.com/install.sh | sh
          fi
          
          # Authenticate with Tailscale using OAuth
          export TS_OAUTH_CLIENT_ID="$TAILSCALE_OAUTH_CLIENT_ID"
          export TS_OAUTH_CLIENT_SECRET="$TAILSCALE_OAUTH_CLIENT_SECRET"
          
          # Get list of devices
          DEVICES=$(tailscale status --json 2>/dev/null || echo '{"Peer":{}}')
          
          # Calculate cutoff timestamp
          CUTOFF_TIMESTAMP=$(date -u -d "$DAYS_OFFLINE days ago" +%s 2>/dev/null || \
                             date -u -v-${DAYS_OFFLINE}d +%s)
          
          REMOVED_COUNT=0
          SKIPPED_COUNT=0
          
          # Process each device
          echo "$DEVICES" | jq -r '.Peer | to_entries[] | @json' | while read -r device; do
            DEVICE_NAME=$(echo "$device" | jq -r '.value.HostName')
            DEVICE_ID=$(echo "$device" | jq -r '.key')
            LAST_SEEN=$(echo "$device" | jq -r '.value.LastSeen // empty')
            ONLINE=$(echo "$device" | jq -r '.value.Online')
            
            if [ "$ONLINE" = "false" ] && [ -n "$LAST_SEEN" ]; then
              LAST_SEEN_TIMESTAMP=$(date -d "$LAST_SEEN" +%s 2>/dev/null || \
                                    date -j -f "%Y-%m-%dT%H:%M:%SZ" "$LAST_SEEN" +%s 2>/dev/null || echo "0")
              
              if [ "$LAST_SEEN_TIMESTAMP" -lt "$CUTOFF_TIMESTAMP" ]; then
                echo "Found offline device: $DEVICE_NAME (ID: $DEVICE_ID)"
                echo "  Last seen: $LAST_SEEN"
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "  [DRY RUN] Would remove: $DEVICE_NAME"
                  REMOVED_COUNT=$((REMOVED_COUNT + 1))
                else
                  echo "  üóëÔ∏è  Removing: $DEVICE_NAME"
                  # Note: Requires Tailscale API call or tailscale CLI with admin permissions
                  # This is a placeholder - actual implementation depends on your setup
                  echo "  ‚ö†Ô∏è  Manual removal required via Tailscale admin console"
                  REMOVED_COUNT=$((REMOVED_COUNT + 1))
                fi
              else
                echo "Device $DEVICE_NAME offline but within $DAYS_OFFLINE days, keeping"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              fi
            fi
          done
          
          echo ""
          echo "üìä Summary:"
          echo "  Devices to remove: $REMOVED_COUNT"
          echo "  Devices kept: $SKIPPED_COUNT"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "‚ÑπÔ∏è  This was a dry run. No devices were actually removed."
            echo "   Set dry_run=false to perform actual cleanup."
          fi
          
          echo ""
          echo "üí° Note: With ephemeral auth keys, devices should auto-remove."
          echo "   This cleanup is a backup mechanism for edge cases."
          EOF
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Summary
        run: |
          echo "‚úÖ Tailscale cleanup completed"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "‚ÑπÔ∏è  Dry run mode - no changes made"
          fi
          echo ""
          echo "Reminder: Ephemeral devices auto-remove when offline."
