# ⚠️ SECURITY NOTICE:
# This workflow defaults to GitHub-hosted runners for safety in public repositories.
# Only use runner_type: "self-hosted" in PRIVATE repositories with trusted contributors.
# Fork PRs will require manual approval before running infrastructure operations.

name: "Reusable Manual Onboarding"

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      target_ip:
        type: string
        description: 'Target IP Address'
        required: true
      ssh_user:
        type: string
        description: 'SSH User'
        required: true
        default: 'deploy'
      target_hostname:
        type: string
        description: 'Hostname to set'
        required: true
      ansible_roles:
        type: string
        description: 'Comma-separated list of Ansible roles to apply (e.g., nginx,mgmt-docker). base_setup always runs by default unless mgmt-docker is specified.'
        required: false
        default: ''
      # Octopus Deploy configuration
      octopus_environment:
        type: string
        description: 'Octopus Deploy environment (Development, Staging, Production)'
        required: false
        default: 'Development'
      octopus_roles:
        type: string
        description: 'Comma-separated Octopus roles (e.g., web-server,nginx)'
        required: false
        default: ''
      skip_octopus:
        type: boolean
        description: 'Skip Octopus Tentacle registration'
        required: false
        default: false
      # Runner configuration
      runner_type:
        type: string
        description: 'Runner type: "github-hosted" (uses ubuntu-latest with Tailscale) or "self-hosted" (uses self-hosted runner with direct LAN access). ⚠️ Use self-hosted ONLY in private repositories.'
        required: false
        default: 'github-hosted'
      tailscale_tags:
        type: string
        description: 'Tailscale ACL tags for GitHub-hosted runner (comma-separated, e.g., "tag:ci,tag:provision")'
        required: false
        default: 'tag:ci'
    secrets:
      DOPPLER_TOKEN:
        required: true
      DOPPLER_TARGET_PROJECT:
        required: true
      DOPPLER_TARGET_CONFIG:
        required: true
      GH_PAT:
        required: true
      # Optional: Required for GitHub-hosted runners
      TS_OAUTH_CLIENT_ID:
        required: false
      TS_OAUTH_CLIENT_SECRET:
        required: false

jobs:
  check-runner-access:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      runner: ${{ steps.select-runner.outputs.runner }}
    steps:
      - name: Select runner based on org membership
        id: select-runner
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const requestedRunner = '${{ inputs.runner_type }}';
            
            // Default to github-hosted
            let runner = 'ubuntu-latest';
            
            // SECURITY: Block external callers from using self-hosted runners
            // This protects against old commit SHA references
            if (context.repo.owner !== 'KoraMaple' || context.repo.repo !== 'nante-reusable-workflow') {
              core.warning('⚠️ External workflow call detected - forcing github-hosted runner for security');
              core.warning(`Called from: ${context.repo.owner}/${context.repo.repo}`);
              core.setOutput('runner', 'ubuntu-latest');
              return;
            }
            
            // Block fork PRs from self-hosted
            if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
              const prRepo = context.payload.pull_request?.head?.repo?.full_name;
              if (prRepo !== `${context.repo.owner}/${context.repo.repo}`) {
                core.warning('Fork PRs use GitHub-hosted runners only');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
            }
            
            // If self-hosted requested, verify org membership
            if (requestedRunner === 'self-hosted') {
              if (context.repo.owner !== 'KoraMaple') {
                core.warning('Self-hosted only available for KoraMaple org repos');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
              
              try {
                const { data } = await github.rest.orgs.getMembershipForUser({
                  org: 'KoraMaple',
                  username: context.actor
                });
                if (data.state === 'active') {
                  core.info(`✓ ${context.actor} is KoraMaple org member - self-hosted allowed`);
                  runner = 'self-hosted';
                }
              } catch (e) {
                core.warning(`${context.actor} is not a KoraMaple org member - using GitHub-hosted`);
              }
            }
            
            core.setOutput('runner', runner);

  onboard:
    needs: check-runner-access
    runs-on: ${{ needs.check-runner-access.outputs.runner }}
    # Prevent fork PRs from running infrastructure operations - maintainers must explicitly trigger
    if: |
      github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name == github.repository
    steps:
      # Connect to Tailscale for GitHub-hosted runners
      - name: Connect to Tailscale
        if: needs.check-runner-access.outputs.runner == 'ubuntu-latest'
        uses: tailscale/github-action@53acf823325fe9ca47f4cdaa951f90b4b0de5bb9 # v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          tags: ${{ inputs.tailscale_tags }}

      - name: Validate inputs
        run: |
          set -e
          
          # Validate IP address format (if provided)
          TARGET_IP="${{ inputs.target_ip }}"
          if [ -n "$TARGET_IP" ]; then
            if [[ ! "$TARGET_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              echo "::error::IP address format is invalid"
              exit 1
            fi
            echo "✓ IP address format validated: $TARGET_IP"
          fi
          
          # Validate ssh_user (if provided - alphanumeric and underscores only)
          SSH_USER="${{ inputs.ssh_user }}"
          if [ -n "$SSH_USER" ]; then
            if [[ ! "$SSH_USER" =~ ^[a-z_][a-z0-9_-]{0,31}$ ]]; then
              echo "::error::ssh_user must be a valid Unix username"
              exit 1
            fi
            echo "✓ ssh_user validated: $SSH_USER"
          fi
          
          # Validate hostname (if provided)
          HOSTNAME="${{ inputs.target_hostname }}"
          if [ -n "$HOSTNAME" ]; then
            if [[ ! "$HOSTNAME" =~ ^[a-zA-Z][a-zA-Z0-9-]{0,62}$ ]]; then
              echo "::error::target_hostname must be a valid hostname (start with letter, alphanumeric and hyphens, max 63 chars)"
              exit 1
            fi
            echo "✓ target_hostname validated: $HOSTNAME"
          fi
          
          echo "✓ All input validation passed"

      - name: Checkout Reusable Workflow Repo
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          repository: KoraMaple/nante-reusable-workflow
          ref: develop
          token: ${{ secrets.GH_PAT }}
          
      - name: Install Doppler CLI
        uses: dopplerhq/cli-action@v3 # v3
      
      # Install Terraform for GitHub-hosted runners (self-hosted runners have it pre-installed)
      # Required for generating Tailscale auth keys via Terraform provider
      - name: Install Terraform
        if: needs.check-runner-access.outputs.runner == 'ubuntu-latest'
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269571cb # v3.1.2
        with:
          terraform_wrapper: false

      - name: Configure Doppler
        run: |
          doppler setup --project "${{ secrets.DOPPLER_TARGET_PROJECT }}" --config "${{ secrets.DOPPLER_TARGET_CONFIG }}" --no-interactive
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Generate Tailscale Auth Key
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Mask all sensitive values to prevent log exposure
          [ -n "$TAILSCALE_OAUTH_CLIENT_SECRET" ] && echo "::add-mask::$TAILSCALE_OAUTH_CLIENT_SECRET"
          [ -n "$SSH_PRIVATE_KEY" ] && echo "::add-mask::$SSH_PRIVATE_KEY"
          [ -n "$ANS_SSH_PUBLIC_KEY" ] && echo "::add-mask::$ANS_SSH_PUBLIC_KEY"
          [ -n "$FREEIPA_ADMIN_PASSWORD" ] && echo "::add-mask::$FREEIPA_ADMIN_PASSWORD"
          [ -n "$OCTOPUS_API_KEY" ] && echo "::add-mask::$OCTOPUS_API_KEY"
          [ -n "$TS_AUTHKEY" ] && echo "::add-mask::$TS_AUTHKEY"
          [ -n "$TAILSCALE_AUTH_KEY" ] && echo "::add-mask::$TAILSCALE_AUTH_KEY"
          
          # Create temporary Terraform config for auth key generation
          mkdir -p /tmp/tailscale-onboard
          cd /tmp/tailscale-onboard
          
          cat > main.tf <<'TFEOF'
          terraform {
            required_providers {
              tailscale = {
                source  = "tailscale/tailscale"
                version = "~> 0.17"
              }
            }
          }
          
          provider "tailscale" {
            # Uses environment variables from Doppler:
            # TAILSCALE_OAUTH_CLIENT_ID
            # TAILSCALE_OAUTH_CLIENT_SECRET
            # TAILSCALE_TAILNET
          }
          
          resource "tailscale_tailnet_key" "onboard_key" {
            reusable      = true
            ephemeral     = false
            preauthorized = true
            expiry        = 7776000  # 90 days
            description   = "Onboarding key for ${{ inputs.target_hostname }}"
          }
          
          output "auth_key" {
            value     = tailscale_tailnet_key.onboard_key.key
            sensitive = true
          }
          TFEOF
          
          # Initialize and apply
          echo "Generating Tailscale auth key via Terraform..."
          terraform init -no-color
          terraform apply -auto-approve -no-color
          
          # Export auth key for Ansible (masked for security)
          export TS_AUTHKEY=$(terraform output -raw auth_key)
          if [ -n "$TS_AUTHKEY" ]; then
            echo "::add-mask::$TS_AUTHKEY"
            echo "TS_AUTHKEY=$TS_AUTHKEY" >> $GITHUB_ENV
            echo "✓ Tailscale auth key generated"
          else
            echo "⚠️  Failed to generate Tailscale auth key"
          fi
          
          # Cleanup
          cd /
          rm -rf /tmp/tailscale-onboard
          EOF
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Run Ansible with Doppler
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Mask all sensitive values to prevent log exposure
          [ -n "$SSH_PRIVATE_KEY" ] && echo "::add-mask::$SSH_PRIVATE_KEY"
          [ -n "$ANS_SSH_PUBLIC_KEY" ] && echo "::add-mask::$ANS_SSH_PUBLIC_KEY"
          [ -n "$FREEIPA_ADMIN_PASSWORD" ] && echo "::add-mask::$FREEIPA_ADMIN_PASSWORD"
          [ -n "$OCTOPUS_API_KEY" ] && echo "::add-mask::$OCTOPUS_API_KEY"
          [ -n "$TS_AUTHKEY" ] && echo "::add-mask::$TS_AUTHKEY"
          [ -n "$TAILSCALE_AUTH_KEY" ] && echo "::add-mask::$TAILSCALE_AUTH_KEY"
          
          # Setup SSH agent with key from Doppler
          eval $(ssh-agent -s)
          echo "$SSH_PRIVATE_KEY" | ssh-add -
          
          cd ansible/
          
          # Install requirements
          ansible-galaxy install -r requirements.yml
          
          # Test connectivity
          echo "Testing Ansible connectivity to ${{ inputs.target_ip }}..."
          if ! ansible all -i "${{ inputs.target_ip }}," -m ping \
            --user "${{ inputs.ssh_user }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no -o ConnectTimeout=10'; then
            echo "❌ ERROR: Ansible cannot connect to VM at ${{ inputs.target_ip }}"
            exit 1
          fi
          echo "✓ Ansible connectivity confirmed"
          
          # Parse Octopus roles from comma-separated string to JSON array
          OCTOPUS_ROLES_JSON="[]"
          if [ -n "${{ inputs.octopus_roles }}" ]; then
            # Simple bash parsing - no jq needed
            IFS=',' read -ra ROLES <<< "${{ inputs.octopus_roles }}"
            OCTOPUS_ROLES_JSON="["
            for i in "${!ROLES[@]}"; do
              ROLE=$(echo "${ROLES[$i]}" | xargs)  # trim whitespace
              if [ -n "$ROLE" ]; then
                [ "$i" -gt 0 ] && OCTOPUS_ROLES_JSON+=","
                OCTOPUS_ROLES_JSON+="\"$ROLE\""
              fi
            done
            OCTOPUS_ROLES_JSON+="]"
          fi
          
          # Export Tailscale auth key for Ansible
          export TS_AUTHKEY="$TS_AUTHKEY"
          
          if [ -z "$TS_AUTHKEY" ]; then
            echo "⚠️  WARNING: No Tailscale auth key available. Tailscale will not be configured."
          else
            echo "✓ Using Tailscale auth key for onboarding"
          fi
          
          # Parse ansible_roles from comma-separated string to JSON array
          ANSIBLE_ROLES_JSON="[]"
          if [ -n "${{ inputs.ansible_roles }}" ]; then
            IFS=',' read -ra ROLES <<< "${{ inputs.ansible_roles }}"
            ANSIBLE_ROLES_JSON="["
            for i in "${!ROLES[@]}"; do
              ROLE=$(echo "${ROLES[$i]}" | xargs)  # trim whitespace
              if [ -n "$ROLE" ]; then
                [ "$i" -gt 0 ] && ANSIBLE_ROLES_JSON+=","
                ANSIBLE_ROLES_JSON+="\"$ROLE\""
              fi
            done
            ANSIBLE_ROLES_JSON+="]"
          fi
          
          echo "Ansible roles to apply: $ANSIBLE_ROLES_JSON"
          
          # Run playbook with Octopus configuration
          # Octopus Tentacle is now part of base_setup, so it runs automatically
          ansible-playbook -i "${{ inputs.target_ip }}," site.yml \
            --user "${{ inputs.ssh_user }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no' \
            --extra-vars "target_hostname=${{ inputs.target_hostname }}" \
            --extra-vars "ansible_roles=$ANSIBLE_ROLES_JSON" \
            --extra-vars "octopus_environment=${{ inputs.octopus_environment }}" \
            --extra-vars "octopus_roles=$OCTOPUS_ROLES_JSON"
          
          echo "✓ Infrastructure onboarded and configured"
          echo "✓ Octopus Tentacle installed and registered"
          EOF