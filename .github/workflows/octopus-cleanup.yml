# ‚ö†Ô∏è SECURITY NOTICE:
# This workflow defaults to GitHub-hosted runners for safety in public repositories.
# Only use runner_type: "self-hosted" in PRIVATE repositories with trusted contributors.
# Fork PRs will require manual approval before running infrastructure operations.

name: Cleanup Orphaned Octopus Targets

on:
  schedule:
    # Run weekly on Sunday at 2 AM
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      days_offline:
        description: 'Remove targets offline for more than X days'
        required: false
        default: '7'
        type: string
      dry_run:
        description: 'Dry run - only show what would be deleted'
        required: false
        default: true
        type: boolean
      runner_type:
        description: 'Runner type: "github-hosted" or "self-hosted". ‚ö†Ô∏è Use self-hosted ONLY in private repositories.'
        required: false
        default: 'github-hosted'
        type: string
      tailscale_tags:
        description: 'Tailscale ACL tags for GitHub-hosted runner'
        required: false
        default: 'tag:ci'
        type: string

# Limit permissions for security
permissions:
  contents: read

jobs:
  check-runner-access:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      runner: ${{ steps.select-runner.outputs.runner }}
    steps:
      - name: Select runner based on org membership
        id: select-runner
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const requestedRunner = '${{ inputs.runner_type || 'github-hosted' }}';
            
            // Default to github-hosted
            let runner = 'ubuntu-latest';
            
            // SECURITY: Block external callers from using self-hosted runners
            // This protects against old commit SHA references
            if (context.repo.owner !== 'KoraMaple' || context.repo.repo !== 'nante-reusable-workflow') {
              core.warning('‚ö†Ô∏è External workflow call detected - forcing github-hosted runner for security');
              core.warning(`Called from: ${context.repo.owner}/${context.repo.repo}`);
              core.setOutput('runner', 'ubuntu-latest');
              return;
            }
            
            // Block fork PRs from self-hosted
            if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
              const prRepo = context.payload.pull_request?.head?.repo?.full_name;
              if (prRepo !== `${context.repo.owner}/${context.repo.repo}`) {
                core.warning('Fork PRs use GitHub-hosted runners only');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
            }
            
            // If self-hosted requested, verify org membership
            if (requestedRunner === 'self-hosted') {
              if (context.repo.owner !== 'KoraMaple') {
                core.warning('Self-hosted only available for KoraMaple org repos');
                core.setOutput('runner', 'ubuntu-latest');
                return;
              }
              
              try {
                const { data } = await github.rest.orgs.getMembershipForUser({
                  org: 'KoraMaple',
                  username: context.actor
                });
                if (data.state === 'active') {
                  core.info(`‚úì ${context.actor} is KoraMaple org member - self-hosted allowed`);
                  runner = 'self-hosted';
                }
              } catch (e) {
                core.warning(`${context.actor} is not a KoraMaple org member - using GitHub-hosted`);
              }
            }
            
            core.setOutput('runner', runner);

  cleanup:
    needs: check-runner-access
    runs-on: ${{ needs.check-runner-access.outputs.runner }}
    # Prevent fork PRs from running infrastructure operations - maintainers must explicitly trigger
    if: |
      github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name == github.repository
    
    steps:
      # Connect to Tailscale for GitHub-hosted runners
      - name: Connect to Tailscale
        if: needs.check-runner-access.outputs.runner == 'ubuntu-latest'
        uses: tailscale/github-action@53acf823325fe9ca47f4cdaa951f90b4b0de5bb9 # v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          tags: ${{ inputs.tailscale_tags }}

      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Install Doppler CLI
        uses: dopplerhq/cli-action@v3 # v3
      
      - name: Configure Doppler
        run: |
          doppler setup --project "${{ secrets.DOPPLER_TARGET_PROJECT }}" --config "${{ secrets.DOPPLER_TARGET_CONFIG }}" --no-interactive
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Find and Remove Orphaned Octopus Targets
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Mask all sensitive values to prevent log exposure
          [ -n "$OCTOPUS_API_KEY" ] && echo "::add-mask::$OCTOPUS_API_KEY"
          [ -n "$TAILSCALE_OAUTH_CLIENT_SECRET" ] && echo "::add-mask::$TAILSCALE_OAUTH_CLIENT_SECRET"
          [ -n "$TS_AUTHKEY" ] && echo "::add-mask::$TS_AUTHKEY"
          
          DAYS_OFFLINE="${{ inputs.days_offline || '7' }}"
          DRY_RUN="${{ inputs.dry_run || 'true' }}"
          
          echo "üîç Searching for Octopus targets offline for more than $DAYS_OFFLINE days..."
          echo "Dry run: $DRY_RUN"
          
          # Get all deployment targets
          TARGETS=$(curl -s -H "X-Octopus-ApiKey: $OCTOPUS_API_KEY" \
            "$OCTOPUS_SERVER_URL/api/$OCTOPUS_SPACE_ID/machines" | jq -r '.Items[]')
          
          # Calculate cutoff date (X days ago)
          CUTOFF_DATE=$(date -u -d "$DAYS_OFFLINE days ago" +%Y-%m-%dT%H:%M:%S 2>/dev/null || \
                        date -u -v-${DAYS_OFFLINE}d +%Y-%m-%dT%H:%M:%S)
          
          REMOVED_COUNT=0
          SKIPPED_COUNT=0
          
          # Process each target
          echo "$TARGETS" | jq -c '.' | while read -r target; do
            TARGET_ID=$(echo "$target" | jq -r '.Id')
            TARGET_NAME=$(echo "$target" | jq -r '.Name')
            TARGET_STATUS=$(echo "$target" | jq -r '.HealthStatus')
            LAST_SEEN=$(echo "$target" | jq -r '.StatusSummary // empty')
            
            # Check if target is unavailable/offline
            if [[ "$TARGET_STATUS" == "Unavailable" ]] || [[ "$TARGET_STATUS" == "Offline" ]]; then
              echo "Found offline target: $TARGET_NAME (ID: $TARGET_ID, Status: $TARGET_STATUS)"
              
              # Get machine details for last health check
              MACHINE_DETAILS=$(curl -s -H "X-Octopus-ApiKey: $OCTOPUS_API_KEY" \
                "$OCTOPUS_SERVER_URL/api/$OCTOPUS_SPACE_ID/machines/$TARGET_ID")
              
              LAST_HEALTH_CHECK=$(echo "$MACHINE_DETAILS" | jq -r '.HealthStatus.LastHealthCheckUtc // empty')
              
              if [ -n "$LAST_HEALTH_CHECK" ]; then
                # Compare dates
                if [[ "$LAST_HEALTH_CHECK" < "$CUTOFF_DATE" ]]; then
                  echo "  ‚ö†Ô∏è  Last seen: $LAST_HEALTH_CHECK (older than $DAYS_OFFLINE days)"
                  
                  if [ "$DRY_RUN" = "true" ]; then
                    echo "  [DRY RUN] Would remove: $TARGET_NAME"
                    REMOVED_COUNT=$((REMOVED_COUNT + 1))
                  else
                    echo "  üóëÔ∏è  Removing: $TARGET_NAME"
                    curl -s -X DELETE -H "X-Octopus-ApiKey: $OCTOPUS_API_KEY" \
                      "$OCTOPUS_SERVER_URL/api/$OCTOPUS_SPACE_ID/machines/$TARGET_ID"
                    REMOVED_COUNT=$((REMOVED_COUNT + 1))
                  fi
                else
                  echo "  ‚úì Last seen: $LAST_HEALTH_CHECK (within $DAYS_OFFLINE days, keeping)"
                  SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                fi
              else
                echo "  ‚ö†Ô∏è  No health check data available, skipping"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              fi
            fi
          done
          
          echo ""
          echo "üìä Summary:"
          echo "  Targets removed: $REMOVED_COUNT"
          echo "  Targets skipped: $SKIPPED_COUNT"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "‚ÑπÔ∏è  This was a dry run. No targets were actually removed."
            echo "   Set dry_run=false to perform actual cleanup."
          fi
          EOF
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

      - name: Summary
        run: |
          echo "‚úÖ Octopus cleanup completed"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "‚ÑπÔ∏è  Dry run mode - no changes made"
          fi
