name: "Reusable VM Provisioning"

on:
  workflow_call:
    inputs:
      app_name:
        type: string
        description: 'Application Name (e.g. nexus, k3s, octopus)'
        required: true
        default: 'app'
      vlan_tag:
        type: string
        description: 'Network Zone'
        default: '20'
      vm_target_ip:
        type: string
        description: 'Target IP Address'
        required: true
      cpu_cores:
        type: string
        description: 'CPU Cores'
        required: true
        default: '2'
      ram_mb:
        type: string
        description: 'RAM in MB'
        required: true
        default: '4096'
      disk_gb:
        type: string
        description: 'Disk Size (e.g. 20G)'
        required: true
        default: '20G'
      # Optional infrastructure overrides
      proxmox_node:
        type: string
        description: 'Proxmox node to deploy on'
        required: false
        default: 'pmx'
      proxmox_storage:
        type: string
        description: 'Storage pool for VM disks'
        required: false
        default: 'zfs-vm'
      vm_template:
        type: string
        description: 'VM template to clone'
        required: false
        default: 'ubuntu-2404-template'
      # Skip Terraform for existing VMs
      skip_terraform:
        type: boolean
        description: 'Skip Terraform provisioning (use existing VM)'
        required: false
        default: false
    secrets:
      DOPPLER_TOKEN:
        required: true
      GH_PAT:
        required: true

jobs:
  provision:
    runs-on: self-hosted
    
    steps:
      - name: Checkout Reusable Workflow Repo
        uses: actions/checkout@v4
        with:
          repository: KoraMaple/nante-reusable-workflow
          ref: develop
          token: ${{ secrets.GH_PAT }}

      - name: Install Doppler CLI
        uses: dopplerhq/cli-action@v3
        with:
          doppler_token: ${{ secrets.DOPPLER_TOKEN }}

      - name: Validate VLAN and IP Match
        run: |
          VLAN="${{ inputs.vlan_tag }}"
          IP="${{ inputs.vm_target_ip }}"
          EXPECTED_PREFIX="192.168.${VLAN}."
          
          if [[ ! "$IP" == ${EXPECTED_PREFIX}* ]]; then
            echo "❌ Error: IP '$IP' does not match VLAN $VLAN (expected ${EXPECTED_PREFIX}x)"
            exit 1
          fi
          echo "✓ VLAN $VLAN and IP $IP are valid"

      - name: Terraform Init, Plan, and Apply
        if: ${{ inputs.skip_terraform != true }}
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Verify credentials are available
          if [ -z "$MINIO_ROOT_USER" ] || [ -z "$MINIO_ROOT_PASSWORD" ]; then
            echo "❌ ERROR: MINIO_ROOT_USER or MINIO_ROOT_PASSWORD not found in environment"
            exit 1
          fi
          
          cd terraform/
          
          # Set AWS credentials for Terraform S3 backend
          export AWS_ACCESS_KEY_ID="$MINIO_ROOT_USER"
          export AWS_SECRET_ACCESS_KEY="$MINIO_ROOT_PASSWORD"
          
          # Terraform Init
          terraform init \
            -backend-config="bucket=terraform-state" \
            -backend-config='endpoints={s3="http://192.168.20.10:9000"}' \
            -backend-config="access_key=$MINIO_ROOT_USER" \
            -backend-config="secret_key=$MINIO_ROOT_PASSWORD"
          
          # Select workspace
          terraform workspace select ${{ inputs.app_name }} || terraform workspace new ${{ inputs.app_name }}
          
          # Set Proxmox credentials
          export TF_VAR_proxmox_api_url="$PROXMOX_API_URL"
          export TF_VAR_proxmox_api_token_id="$PROXMOX_TOKEN_ID"
          export TF_VAR_proxmox_api_token_secret="$PROXMOX_TOKEN_SECRET"
          export TF_VAR_ssh_public_key="$ANS_SSH_PUBLIC_KEY"
          
          # Terraform Plan
          terraform plan \
            -var="app_name=${{ inputs.app_name }}" \
            -var="vlan_tag=${{ inputs.vlan_tag }}" \
            -var="vm_target_ip=${{ inputs.vm_target_ip }}" \
            -var="vm_cpu_cores=${{ inputs.cpu_cores }}" \
            -var="vm_ram_mb=${{ inputs.ram_mb }}" \
            -var="vm_disk_gb=${{ inputs.disk_gb }}" \
            -var="proxmox_target_node=${{ inputs.proxmox_node }}" \
            -var="proxmox_storage=${{ inputs.proxmox_storage }}" \
            -var="vm_template=${{ inputs.vm_template }}" \
            -out=tfplan
          
          # Terraform Apply
          terraform apply tfplan
          EOF

      - name: Wait for VM to boot and SSH to be ready
        run: |
          echo "Waiting for VM at ${{ inputs.vm_target_ip }} to be reachable..."
          
          # Wait up to 3 minutes for the VM to respond to ping
          PING_SUCCESS=false
          for i in {1..36}; do
            if ping -c 1 -W 2 ${{ inputs.vm_target_ip }} &>/dev/null; then
              echo "✓ VM is responding to ping (attempt $i)"
              PING_SUCCESS=true
              break
            fi
            echo "Attempt $i/36: VM not yet reachable, waiting 5s..."
            sleep 5
          done
          
          if [ "$PING_SUCCESS" = false ]; then
            echo "❌ ERROR: VM did not respond to ping after 3 minutes"
            echo "Check that:"
            echo "  1. VM was created successfully in Proxmox"
            echo "  2. Cloud-init completed (check VM console)"
            echo "  3. Network configuration is correct (VLAN ${{ inputs.vlan_tag }})"
            echo "  4. IP ${{ inputs.vm_target_ip }} is not already in use"
            exit 1
          fi
          
          # Wait for SSH port to be open (up to 2 minutes)
          echo "Waiting for SSH port 22..."
          SSH_SUCCESS=false
          for i in {1..24}; do
            if nc -z -w 2 ${{ inputs.vm_target_ip }} 22 2>/dev/null; then
              echo "✓ SSH port is open (attempt $i)"
              SSH_SUCCESS=true
              break
            fi
            echo "Attempt $i/24: SSH not ready, waiting 5s..."
            sleep 5
          done
          
          if [ "$SSH_SUCCESS" = false ]; then
            echo "❌ ERROR: SSH port did not open after 2 minutes"
            echo "Check that:"
            echo "  1. Cloud-init completed successfully"
            echo "  2. SSH service is running on the VM"
            echo "  3. Firewall is not blocking port 22"
            exit 1
          fi
          
          # Additional wait for cloud-init to fully complete
          echo "Waiting 15s for cloud-init to complete..."
          sleep 15
          echo "✓ VM is ready for Ansible configuration"

      - name: Run Ansible with Doppler
        run: |
          doppler run -- bash <<'EOF'
          set -e
          
          # Setup SSH agent with key from Doppler
          eval $(ssh-agent -s)
          echo "$SSH_PRIVATE_KEY" | ssh-add -
          
          cd ansible/
          
          # Install requirements
          ansible-galaxy install -r requirements.yml
          
          # Test connectivity
          echo "Testing Ansible connectivity to ${{ inputs.vm_target_ip }}..."
          if ! ansible all -i "${{ inputs.vm_target_ip }}," -m ping \
            --user deploy \
            --ssh-common-args='-o StrictHostKeyChecking=no -o ConnectTimeout=10'; then
            echo "❌ ERROR: Ansible cannot connect to VM"
            exit 1
          fi
          echo "✓ Ansible connectivity confirmed"
          
          # Run playbook
          ansible-playbook -i "${{ inputs.vm_target_ip }}," site.yml \
            --user deploy \
            --ssh-common-args='-o StrictHostKeyChecking=no' \
            --extra-vars "target_hostname=${{ inputs.app_name }}" \
            --extra-vars "vlan_tag=${{ inputs.vlan_tag }}" \
            --extra-vars "app_role_name=${{ inputs.app_name }}"
          EOF