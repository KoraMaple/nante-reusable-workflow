---
# Detect if running in LXC container
- name: Check virtualization type
  shell: systemd-detect-virt
  register: virt_type
  changed_when: false
  failed_when: false

- name: Set LXC fact
  set_fact:
    is_lxc: "{{ virt_type.stdout == 'lxc' }}"

# Hostname configuration
- name: Set system hostname (non-LXC)
  hostname:
    name: "{{ target_hostname }}"
  when: not is_lxc

- name: Set hostname directly in LXC
  shell: |
    echo "{{ target_hostname }}" > /etc/hostname
    hostname "{{ target_hostname }}"
  when: is_lxc
  changed_when: true

- name: Update /etc/hosts with new hostname
  lineinfile:
    path: /etc/hosts
    regexp: '^127.0.1.1'
    line: "127.0.1.1 {{ target_hostname }}"

- name: Configure apt for non-interactive mode
  copy:
    content: |
      Dpkg::Options {
         "--force-confdef";
         "--force-confold";
      }
      APT::Get::Assume-Yes "true";
      APT::Install-Recommends "false";
    dest: /etc/apt/apt.conf.d/99-noninteractive
    mode: '0644'

- name: Wait for apt lock to be released
  shell: |
    # Wait up to 5 minutes for apt locks to be released
    TIMEOUT=300
    ELAPSED=0
    while [ $ELAPSED -lt $TIMEOUT ]; do
      if ! fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && \
         ! fuser /var/lib/apt/lists/lock >/dev/null 2>&1 && \
         ! fuser /var/cache/apt/archives/lock >/dev/null 2>&1; then
        echo "All apt locks released"
        exit 0
      fi
      echo "Waiting for apt lock... ($ELAPSED/$TIMEOUT seconds)"
      sleep 5
      ELAPSED=$((ELAPSED + 5))
    done
    echo "Timeout waiting for apt lock after $TIMEOUT seconds"
    exit 1
  changed_when: false
  retries: 1
  delay: 0

- name: Update apt cache
  shell: apt-get update
  environment:
    DEBIAN_FRONTEND: noninteractive
  changed_when: false
  retries: 3
  delay: 10

- name: Install essential packages
  apt:
    name:
      - curl
      - apt-transport-https
      - ca-certificates
      - gpg
      - unzip
    state: present
    force_apt_get: yes
  environment:
    DEBIAN_FRONTEND: noninteractive

- name: Install rsyslog (non-LXC only)
  apt:
    name: rsyslog
    state: present
    force_apt_get: yes
  environment:
    DEBIAN_FRONTEND: noninteractive
  when: not is_lxc

- name: Install QEMU Guest Agent (VMs only)
  apt:
    name: qemu-guest-agent
    state: present
    force_apt_get: yes
  environment:
    DEBIAN_FRONTEND: noninteractive
  when: virt_type.stdout in ['kvm', 'qemu']

- name: Ensure QEMU Guest Agent is running (VMs only)
  service:
    name: qemu-guest-agent
    state: started
    enabled: yes
  when: virt_type.stdout in ['kvm', 'qemu']

- name: Check if Tailscale is already configured
  command: tailscale status --json
  register: tailscale_status
  failed_when: false
  changed_when: false

- name: Install and configure Tailscale (if not managed by Terraform)
  when: tailscale_status.rc != 0
  block:
    - name: Install Tailscale
      shell: "curl -fsSL https://tailscale.com/install.sh | sh"
      args:
        creates: /usr/bin/tailscale

    - name: Connect to Tailscale
      command: "tailscale up --authkey={{ ts_authkey }} --hostname={{ target_hostname }}"
      environment:
        TS_AUTHKEY: "{{ ts_authkey }}"
      register: tailscale_result
      changed_when: "'Success' in tailscale_result.stdout or tailscale_result.rc == 0"
      failed_when: false

- name: Verify Tailscale is connected
  when: tailscale_status.rc != 0
  block:
    - name: Wait for Tailscale to be online
      command: tailscale status
      register: tailscale_check
      until: tailscale_check.rc == 0
      retries: 10
      delay: 3
      failed_when: false

- name: Display Tailscale status
  debug:
    msg: "Tailscale is {{ 'already configured' if tailscale_status.rc == 0 else 'newly configured' }}"

- name: Debug Observability Connection Vars
  debug:
    msg: "Connecting to Observability Stack at {{ oo_host }}"

- name: Fail if Observability Host is missing
  fail:
    msg: "OO_HOST is not defined. Cannot configure Grafana Alloy."
  when: oo_host is not defined or oo_host | length == 0

- name: Create alloy user with log permissions
  user:
    name: alloy
    system: yes
    groups: adm
    append: yes
    state: present

- name: Install and Configure Grafana Alloy with Debugging
  block:
    - name: Include Alloy Role
      ansible.builtin.include_role:
        name: grafana.grafana.alloy
  rescue:
    - name: Get Alloy Service Logs
      command: journalctl -u alloy -n 50 --no-pager
      register: alloy_logs
      ignore_errors: true

    - name: Print Alloy Logs
      debug:
        var: alloy_logs.stdout_lines

    - name: Fail execution
      fail:
        msg: "Alloy failed to start. See logs above for details."
  vars:
    alloy_config: |
      // 1. Collect System Metrics (node_exporter)
      prometheus.exporter.unix "default" {}

      // Add labels (hostname) to metrics
      discovery.relabel "system_metrics" {
        targets = prometheus.exporter.unix.default.targets
        rule {
          target_label = "instance"
          replacement  = "{{ target_hostname }}"
        }
        rule {
          target_label = "job"
          replacement  = "node_exporter"
        }
      }

      prometheus.scrape "metrics" {
        targets    = discovery.relabel.system_metrics.output
        forward_to = [prometheus.remote_write.grafana_stack.receiver]
      }

      prometheus.remote_write "grafana_stack" {
        endpoint {
          url = "http://{{ oo_host }}:9090/api/v1/write"
        }
      }

      // 2. Collect System Logs
      local.file_match "system_logs" {
        path_targets = [
          {
            __path__ = "/var/log/*.log",
            host     = "{{ target_hostname }}",
            job      = "system",
          },
          {
            __path__ = "/var/log/syslog",
            host     = "{{ target_hostname }}",
            job      = "system",
          },
        ]
      }

      loki.source.file "system_scrape" {
        targets    = local.file_match.system_logs.targets
        forward_to = [loki.write.grafana_stack.receiver]
      }

      loki.write "grafana_stack" {
        endpoint {
          url = "http://{{ oo_host }}:3100/loki/api/v1/push"
        }
      }

# LDAP/FreeIPA Client Configuration
# Enroll all servers with FreeIPA for centralized authentication
- name: Include LDAP client configuration
  include_role:
    name: ldap-config
  when:
    - freeipa_server_ip is defined
    - freeipa_server_ip | length > 0
    - freeipa_admin_password is defined
    - freeipa_admin_password | length > 0
    - target_hostname != 'freeipa'  # Don't enroll FreeIPA server with itself

# Octopus Deploy Tentacle Installation
# Every VM should be registered with Octopus for deployment orchestration
- name: Include Octopus Tentacle installation
  include_role:
    name: octopus-tentacle
  vars:
    target_name: "{{ target_hostname }}"
    octopus_environment: "{{ octopus_environment | default('Development') }}"
    target_roles: "{{ octopus_roles | default([]) }}"
  when: 
    - octopus_server_url is defined
    - octopus_server_url | length > 0
    - octopus_api_key is defined
    - octopus_api_key | length > 0